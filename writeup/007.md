1、查看文件类型
```bash
file 007
007: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), BuildID[sha1]=383b0a064d21112919a6dcc53ee45b4cfa179e61, for GNU/Linux 3.2.0, not stripped
```
可以看到是linux可执行文件，执行一下，看到需要输入密码
有两种思路：爆破和反汇编
爆破嘛，可是可以，但是～～～呃呃呃，跟技术没多大关系，主要是字典要好，就不说了

2、反汇编
我用的工具是IDA，业界最好的工具了吧应该是
打开文件，找到主函数main，按F5，生成对应的c代码，内容如下：
```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax
  signed int i; // [rsp+0h] [rbp-80h]
  char s[104]; // [rsp+10h] [rbp-70h]
  unsigned __int64 v6; // [rsp+78h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  printf("Enter password:", argv, envp);
  __isoc99_scanf("%s", s);
  if ( (unsigned int)strlen(s) == 15 )
  {
    for ( i = 0; i <= 15; ++i )
    {
      if ( (char)(str[i] ^ s[i]) != ::result[i] )
        goto LABEL_7;
    }
    puts("success! Hero is never die....");
    result = 0;
  }
  else
  {
LABEL_7:
    puts("keep trying...");
    result = -1;
  }
  return result;
}
```
可以看到，先判断了s的长度是否为15（就是密码长度了，哈哈）
然后按位for循环，判断了str[i]^s[i]是否等于result[i]
异或运算与加减乘除一样，特点如下：
```
a^b=c -> c^a=b c^b=2
a+b=c -> c-a=b c-b=a
```
从c代码可以看出，result就是上面例子中的c，str就是a，b就是我们输入的密码c
即：result^str的结果就是s，正确的密码
所以，剩下的工作就是找到str和result的值。

3、查找result和str的值，打开strings view，结果如下图(第一列为地址信息，可忽略)
```
LOAD:00000000000002A8	0000001C	C	/lib64/ld-linux-x86-64.so.2
LOAD:0000000000000439	0000000A	C	libc.so.6
LOAD:0000000000000443	0000000F	C	__isoc99_scanf
LOAD:0000000000000452	00000005	C	puts
LOAD:0000000000000457	00000011	C	__stack_chk_fail
LOAD:0000000000000468	00000007	C	printf
LOAD:000000000000046F	00000007	C	strlen
LOAD:0000000000000476	0000000F	C	__cxa_finalize
LOAD:0000000000000485	00000012	C	__libc_start_main
LOAD:0000000000000497	0000000A	C	GLIBC_2.7
LOAD:00000000000004A1	0000000A	C	GLIBC_2.4
LOAD:00000000000004AB	0000000C	C	GLIBC_2.2.5
LOAD:00000000000004B7	0000001C	C	_ITM_deregisterTMCloneTable
LOAD:00000000000004D3	0000000F	C	__gmon_start__
LOAD:00000000000004E2	0000001A	C	_ITM_registerTMCloneTable
.rodata:0000000000002008	00000010	C	Enter password:
.rodata:0000000000002020	0000001F	C	success! Hero is never die....
.rodata:000000000000203F	0000000F	C	keep trying...
.eh_frame:00000000000020F7	00000006	C	;*3$\"
.data:0000000000004020	00000010	C	woshijingegeHHH

```
看到有个字符串woshijingegeHHH，再无其他，这个很可能就是result或者str了

找到了一个值，还差另外一个，这个view没有，我们打开hex view,找到有woshijingegeHHH的地方
（第一列为地址信息，可忽略）
```
0000000000003F90  00 00 00 00 00 00 00 00  A8 3D 00 00 00 00 00 00  .........=......
0000000000003FA0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
0000000000003FB0  58 40 00 00 00 00 00 00  60 40 00 00 00 00 00 00  X@......`@......
0000000000003FC0  68 40 00 00 00 00 00 00  70 40 00 00 00 00 00 00  h@......p@......
0000000000003FD0  80 40 00 00 00 00 00 00  90 40 00 00 00 00 00 00  .@.......@......
0000000000003FE0  78 40 00 00 00 00 00 00  98 40 00 00 00 00 00 00  x@.......@......
0000000000003FF0  A0 40 00 00 00 00 00 00  88 40 00 00 00 00 00 00  .@.......@......
0000000000004000  00 00 00 00 00 00 00 00  08 40 00 00 00 00 00 00  .........@......
0000000000004010  24 0B 0A 2E 05 0B 0E 15  20 17 02 04 3C 69 35 00  $....... ...<i5.
0000000000004020  77 6F 73 68 69 6A 69 6E  67 65 67 65 48 48 48 00  woshijingegeHHH.
0000000000004030  ?? ?? ?? ?? ?? ?? ?? ??  ?? ?? ?? ?? ?? ?? ?? ??  ????????????????
0000000000004040  ?? ?? ?? ?? ?? ?? ?? ??  ?? ?? ?? ?? ?? ?? ?? ??  ????????????????
0000000000004050  ??                       00 00 00 00 00 00 00 00  ?       ........
0000000000004060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
0000000000004070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
0000000000004080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
0000000000004090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  ................
00000000000040A0  00 00 00 00 00 00 00 00                           ........        
```

可以看到，在data区域附近，有三行是有有效数据的：(思考：明明是4行，我为啥说3行呢？)
```
240b 0a2e 050b 0e15 2017 0204 3c69 3500  $....... ...<i5.
776f 7368 696a 696e 6765 6765 4848 4800  woshijingegeHHH.
4743 433a 2028 5562 756e 7475 2038 2e33  GCC: (Ubuntu 8.3
2e30 2d36 7562 756e 7475 3129 2038 2e33  .0-6ubuntu1) 8.3
```
排除掉最后一行的编译器信息外，只剩2行，估计就是我们要的result和str了。

4、取出数据，验证一把：
```
package main

import "fmt"

func main(){
	result:=[]byte{0x24,0x0b,0x0a,0x2e,0x05,0x0b,0x0e,0x15,0x20,0x17,0x02,0x04,0x3c,0x69,0x35,0x00}
	str:=[]byte{0x77,0x6f,0x73,0x68,0x69,0x6a,0x69,0x6e,0x67,0x65,0x67,0x65,0x48,0x48,0x48,0x00}

	password:=make([]byte,15)
	for i:=0;i<15;i++{
		password[i] = result[i]^str[i]
	}
	fmt.Printf("password is:%s",password)
}
```
运行一下结果为：
```sh
password is:SdyFlag{Great!}
```
出来了一个结果，是否正确呢？运行一下试试：
```bash
jin@k53:jin-practice/asm$ ./007
Enter password:SdyFlag{Great!}        
success! Hero is never die....
```

5、至此，结束。

当然，用IDA查看strings view可以用vim %!xxd 代替
```
0002f90: 0000 0000 0000 0000 a83d 0000 0000 0000  .........=......
0002fa0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0002fb0: 3610 0000 0000 0000 4610 0000 0000 0000  6.......F.......
0002fc0: 5610 0000 0000 0000 6610 0000 0000 0000  V.......f.......
0002fd0: 7610 0000 0000 0000 0000 0000 0000 0000  v...............
0002fe0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0002ff0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0003000: 0000 0000 0000 0000 0840 0000 0000 0000  .........@......
0003010: 240b 0a2e 050b 0e15 2017 0204 3c69 3500  $....... ...<i5.
0003020: 776f 7368 696a 696e 6765 6765 4848 4800  woshijingegeHHH.
0003030: 4743 433a 2028 5562 756e 7475 2038 2e33  GCC: (Ubuntu 8.3
0003040: 2e30 2d36 7562 756e 7475 3129 2038 2e33  .0-6ubuntu1) 8.3
0003050: 2e30 0000 0000 0000 0000 0000 0000 0000  .0..............
0003060: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0003070: 0000 0000 0300 0100 a802 0000 0000 0000  ................
0003080: 0000 0000 0000 0000 0000 0000 0300 0200  ................
0003090: c402 0000 0000 0000 0000 0000 0000 0000  ................
00030a0: 0000 0000 0300 0300 e802 0000 0000 0000  ................
00030b0: 0000 0000 0000 0000 0000 0000 0300 0400  ................
```

但是具体逻辑的话，得用反汇编工具生成可以理解的代码才能知道了